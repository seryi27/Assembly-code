;**************************************************************************
; SBM 2019. PRÁCTICA 2
;
; SERGIO CORDERO ROJAS Y ELIAS HERNANDIS PRIETO
;
;**************************************************************************
; DEFINICION DEL SEGMENTO DE DATOS
DATOS SEGMENT
DET               DW 0
NUMEROENASCII     DW 5 dup(0) ; UN ARRAY DE 5 DIGITOS DECIMALES
MATRIX            DB 1, 1, 1, 1, 2, 4, 1, 3, 9
ENTRADA           DB 100 DUP(0)
MENSAJE1          DB "INTRODUCE MATRIZ ELEMENTO A ELEMENTO [-16, 15] SEPARADOS POR ESPACIOS:", 0AH, '$'
CUATROESPACIOS    DB "    $"
SALTODELINEA      DB 13, 10, '$'
BARRAABARRA       DB "|A|=$"
OPCION1           DB "1) Calcular el determinante con valores por defecto", 0AH, '$'
OPCION2           DB "2) Calcular el determinante con valores introducidos por teclado", 0AH, '$'
TEXTOELECCION     DB "Teclee 1 o 2 y pulse <Enter>", 0AH, 0AH, 0AH, '$'
TEXTOERROR        DB "Opcion no reconocida", 0AH, '$'
TEXTOERRORPARSING DB "Formato incorrecto o numero demasiado grande", 0AH, '$'


DATOS ENDS
;**************************************************************************
; DEFINICION DEL SEGMENTO DE PILA
PILA SEGMENT STACK "STACK"
DB 40H DUP (0) ;ejemplo de inicialización, 64 bytes inicializados a 0
PILA ENDS
;**************************************************************************
; DEFINICION DEL SEGMENTO EXTRA
EXTRA SEGMENT
RESULT DW 0,0 ;ejemplo de inicialización. 2 PALABRAS (4 BYTES)
EXTRA ENDS
;**************************************************************************
; DEFINICION DEL SEGMENTO DE CODIGO
CODE SEGMENT
ASSUME CS: CODE, DS: DATOS, ES: EXTRA, SS: PILA
; COMIENZO DEL PROCEDIMIENTO PRINCIPAL
INICIO PROC
; INICIALIZA LOS REGISTROS DE SEGMENTO CON SU VALOR
MOV AX, DATOS
MOV DS, AX
MOV AX, PILA
MOV SS, AX
MOV SP, 64 ; CARGA EL PUNTERO DE PILA CON EL VALOR MAS ALTO
; FIN DE LAS INICIALIZACIONES
; COMIENZO DEL PROGRAMA

;PRIMERO IMPRIMIMOS EL MENU PARA QUE EL USUARIO ELIJA SI QUIERE INTRODUCIR LA MATRIZ
;POR TECLADO O USAR LA POR DEFECTO
CALL MENU

;CUANDO YA TENEMOS LA MATRIZ CARGADA COMPROBAMOS QUE SUS COEFICIENTES ESTEN EN RANGO
CALL COMPROBARRANGOS

;VAMOS ACUMULANDO EN LA VARIABLE DET EL VALOR DEL DETERMINANTE (SUMANDO Y RESTANDO LAS 
;DIAGONALES CORRESPONDIENTES)
MOV AL, MATRIX[0]
MOV BL, MATRIX[4]
MOV CH, MATRIX[8]
CALL MUL3ADD

MOV AL, MATRIX[1]
MOV BL, MATRIX[5]
MOV CH, MATRIX[6]
CALL MUL3ADD

MOV AL, MATRIX[2]
MOV BL, MATRIX[3]
MOV CH, MATRIX[7]
CALL MUL3ADD

MOV AL, MATRIX[6]
MOV BL, MATRIX[4]
MOV CH, MATRIX[2]
CALL MUL3SUB

MOV AL, MATRIX[0]
MOV BL, MATRIX[5]
MOV CH, MATRIX[7]
CALL MUL3SUB

MOV AL, MATRIX[1]
MOV BL, MATRIX[3]
MOV CH, MATRIX[8]
CALL MUL3SUB

; IMPRIMIR LA MATRIZ FILA A FILA

; IMPRIMIR LA PRIMERA FILA
MOV DX, OFFSET CUATROESPACIOS
MOV AH, 9
INT 21H
MOV DI, 0
CALL IMPRIMIRFILAMATRIZ
MOV DX, OFFSET SALTODELINEA
MOV AH, 9
INT 21H

; IMPRIMIR LA SEGUNDA FILA Y EL DETERMINANTE
MOV DX, OFFSET BARRAABARRA
MOV AH, 9
INT 21H

MOV DI, 3
CALL IMPRIMIRFILAMATRIZ

MOV DL, '='
MOV AH, 2
INT 21H

; IMPRIMIR EL DETERMINANTE
MOV BX, DET
MOV DX, SEG NUMEROENASCII
MOV AX, OFFSET NUMEROENASCII
CALL PASARAASCII
MOV DX, OFFSET NUMEROENASCII
CALL IMPRIMIR

MOV DX, OFFSET SALTODELINEA
MOV AH, 9
INT 21H

; IMPRIMIR LA TERCERA FILA
MOV DX, OFFSET CUATROESPACIOS
INT 21H

MOV DI, 6
CALL IMPRIMIRFILAMATRIZ

MOV DX, OFFSET SALTODELINEA
INT 21H

; FIN DEL PROGRAMA
MOV AX, 4C00H
INT 21H
INICIO ENDP

; FUNCION QUE, UNA VEZ CARGADOS EN MEMORIA LOS COEFICIENTES DE LA MATRIZ,
; COMPRUEBA SI ESTOS SE ENCUENTRAN EN EL RANGO [-16, 15]
COMPROBARRANGOS PROC NEAR
	PUSH DX
	PUSH DI
	MOV DI, 0
	
	;HACEMOS UN BUCLE COMPROBANDO ELEMENTO A ELEMENTO
	COMPROBARELEMENTO:
		MOV DX, DI
		SUB DX, 9
		JZ TERMINAR
	
		MOV DL, MATRIX[DI]
		SUB DL, 15
		JG FUERADERANGO
		
		MOV DL, MATRIX[DI]
		ADD DL, 16
		JL FUERADERANGO
		
		INC DI
		JMP COMPROBARELEMENTO
	
	;CUANDO COMPROBAMOS LOS 9 ELEMENTOS DE LA MATRIZ SALIMOS
	TERMINAR:
		POP DI
		POP DX
		RET
	
	;SI EL ELEMENTO ESTA FUERA DE RANGO TERMINAMOS LA EJECUCION DEL PROGRAMA
	FUERADERANGO:
		CALL ERRORPARSING
		
COMPROBARRANGOS ENDP

; MUESTRA EL MENÚ INICIAL Y OBTIENE LA MATRIZ POR TECLADO SI ES NECESARIO
MENU PROC NEAR

INICIOMENU:
	PUSH AX
	PUSH DX

	; MOSTRAR EL MENÚ
	MOV DX, OFFSET OPCION1
	MOV AH, 9
	INT 21H
	
	MOV DX, OFFSET OPCION2
	INT 21H
	
	MOV DX, OFFSET TEXTOELECCION
	INT 21H
	
	MOV AH,0AH			;ALMACENA LA OPCIÓN TECLEADA
	MOV DX, OFFSET ENTRADA
	MOV ENTRADA[0], 100
	INT 21H
	
	MOV DL, ENTRADA[2] ; LEER A REGISTRO EL CARACTER INTRODUCIDO
	
	;SI LA OPCION ES 1 USAMOS LA MATRIZ EN MEMORIA
	SUB DL, '1'
	JZ MATRIZENMEMORIA
	
	;SI LA OPCION ES 2 USAMOS LA MATRIZ POR TECLADO
	SUB DL, 1
	JZ MATRIZPORTECLADO
	
	;SI LA OPCION ES DISTINTA DE 1 O 2 AVISAMOS AL USUARIO Y VOLVEMOS A PEDIR OPCION
	MOV AH, 9
	MOV DX, OFFSET TEXTOERROR
	INT 21H
	JMP INICIOMENU
	
; SI EL USUARIO ELIGE LA OPCION 1 USAMOS LA MATRIZ CARGADA POR DEFECTO
MATRIZENMEMORIA:
	POP DX
	POP AX
	RET
; SI EL USUARIO ELIGE LA OPCION 2, LEEMOS LA MATRIZ POR TECLADO
MATRIZPORTECLADO:
	CALL LEERMATRIZ
	POP DX
	POP AX
	RET
MENU ENDP

; FUNCION QUE IMPRIME UN MENSAJE DE ERROR Y TERMINA LA EJECUCION DEL PROGRAMA
; LA LLAMAMOS CUANDO ALGUNO DE LOS COEFICIENTES DE LA MATRIZ ESTA FUERA DE RANGO
ERRORPARSING PROC NEAR
	MOV DX, OFFSET TEXTOERRORPARSING
	MOV AH, 9
	INT 21H
	
	; FIN DEL PROGRAMA
	MOV AX, 4C00H
	INT 21H
ERRORPARSING ENDP


; FUNCION QUE LEE POR TECLADO LA MATRIZ 3X3 Y LA ALMACENA EN LA ZONA DE MEMORIA
; DENOMINADA MATRIX
LEERMATRIZ PROC NEAR
	; PUSH { AX, BX, CX, DX, DI, SI }

	MOV DX, OFFSET MENSAJE1
	MOV AH, 9
	INT 21H


	MOV AH,0AH			;ALMACENA LA MATRIZ TECLEADA
	MOV DX, OFFSET ENTRADA
	MOV ENTRADA[0], 100
	INT 21H

	MOV DI, 2 ; INDICE DEL CARACTER EN ENTRADA
	MOV SI, 0 ; ÍNDICE DEL ELEMENTO EN MATRIX
	LEERELEMENTO: ;BUCLE QUE ALMACENA ELEMENTO A ELEMENTO DE LA MATRIZ (HASTA LLEGAR A 9)
		MOV CX, SI
		SUB CX, 9
		JZ MATRIZLEIDA
		
		MOV DX, 0 ; DX = VALOR DEL ENTERO QUE ESTAMOS LEYENDO
		MOV CH, 0 ; CH = FLAG. 1 SI NUMERO NEGATIVO
		
		LEERCARACTER: ; BUCLE QUE LEE CARACTER A CARACTER DE UN MISMO ELEMENTO DE LA MATRIZ
			MOV AH, 0 ; EN AX LAS DECENAS
			MOV AL, ENTRADA[DI]
			
			; SI EL PRIMER CARACTER DEL ELEMENTO ES UN SIGNO MENOS LO TRATAMOS COMO NEGATIVO
			MOV CL, AL
			SUB CL, '-'
			JZ NUMERONEGATIVO
			
			INC DI
			MOV BH, 0 ; EN BX LAS UNIDADES
			MOV BL, ENTRADA[DI]
			
			; SI ES UN NÚMERO DE UN SOLO DÍGITO, PROCESARLO DE MANERA ESPECIAL
			MOV CL, BL
			SUB CL, ' ' ; COMPROBAR SI EL SIGUIENTE CARACTER ES UN ESPACIO
			JZ NUMERODEUNDIGITO
			
			MOV CL, BL
			SUB CL, 0DH ; COMPROBAR SI EL SIGUIENTE CARACTER ES UN RETORNO DE CARRO (CR)
			JZ NUMERODEUNDIGITO
			
			; SI EL NÚMERO TIENE AL MENOS DOS DIGITOS, PRIMERO COMPROBAMOS QUE NO TIENE MÁS DE DOS PARA ASEGURARNOS DE QUE ESTÁ EN EL RANGO SOPORTADO
			MOV CL, ENTRADA[DI][1]
			SUB CL, ' '
			JZ SEGUIR
			
			MOV CL, ENTRADA[DI][1]
			SUB CL, 0DH
			JZ SEGUIR
			JMP ERRORPARSING
			
			SEGUIR:
			SUB AX, '0'
			MOV CL, 10
			MUL CL ; AX = AL * 10 (CALCULA LAS DECENAS DEL NÚMERO)
			ADD DX, AX ; SUMAMOS LAS DECENAS AL NÚMERO
			
			SUB BX, '0'
			ADD DX, BX ; SUMAMOS LAS UNIDADES AL NÚMERO
			

			ADD DI, 2 ; AVANZAR DOS CARACTERES PORQUE SE TRATA DE UN NÚMERO DE DOS CIFRAS
			
			SUB CH, 0
			JNZ NEGARNUMERO
			
			MOV MATRIX[SI], DL
			ADD SI, 1
			JMP LEERELEMENTO
			
		NUMERODEUNDIGITO:
			SUB AX, '0'
			ADD DX, AX
			
			
			ADD DI, 1 ; AVANZAR SOLO UN CARACTER PORQUE SE TRATA DE UN NÚMERO DE UNA SOLA CIFRA
			
			SUB CH, 0
			JNZ NEGARNUMERO
			MOV MATRIX[SI], DL
			ADD SI, 1
			JMP LEERELEMENTO
		
	MATRIZLEIDA:
		MOV AH, 2
		MOV DL, 0AH
		INT 21H
		; POP SI, DI, DX, CX, BX, AX
		RET
		
	NUMERONEGATIVO:
		MOV CH, 1
		ADD DI, 1
		JMP LEERCARACTER
		
	NEGARNUMERO:
		NEG DX
		MOV MATRIX[SI], DL
		ADD SI, 1
		JMP LEERELEMENTO
		
LEERMATRIZ ENDP

; FUNCION QUE MULTIPLICA LOS VALORES CONTENIDOS EN AL, BL Y CH Y SUMA DICHO RESULTADO AL VALOR ACTUAL DE LA VARIABLE DET
MUL3ADD PROC NEAR
	PUSH AX
	PUSH BX
	PUSH CX
	PUSH DX
	
	IMUL BL
	MOV CL, 8
	SAR CX, CL			; EXTENDER EN SIGNO
	IMUL CX
	MOV DX, DET  		; traer el resultado anterior de memoria
	ADD DX, AX 			; SUMAR esta diagonal
	MOV DET, DX 		; guardar el resultado en DET
	
	POP DX
	POP CX
	POP BX
	POP AX
	RET
MUL3ADD ENDP	

; FUNCION QUE MULTIPLICA LOS VALORES CONTENIDOS EN AL, BL Y CH Y RESTA DICHO RESULTADO AL VALOR ACTUAL DE LA VARIABLE DET
MUL3SUB PROC NEAR
	PUSH AX
	PUSH BX
	PUSH CX
	PUSH DX
	
	IMUL BL
	MOV CL, 8
	SAR CX, CL			; EXTENDER EN SIGNO
	IMUL CX
	MOV DX, DET  		; traer el resultado anterior de memoria
	SUB DX, AX 			; RESTAR esta diagonal
	MOV DET, DX 		; guardar el resultado en DET
	
	POP DX
	POP CX
	POP BX
	POP AX
	RET
MUL3SUB ENDP	

; CONVIERTE EL NÚMERO BINARIO GUARDADO EN BX EN UNA CADENA ASCII QUE ALMACENA EN DX:AX
PASARAASCII PROC NEAR
	PUSH SI
	PUSH DX
	PUSH DI
	PUSH CX
	PUSH ES ; SALVAMOS ES
	MOV ES, DX ; CARGAMOS EL SEGMENTO (DX) EN ES
	PUSH BX
	PUSH BP
	MOV BP, AX
	PUSH AX ; SALVAMOS AX

	MOV SI, 0 ; POSICIÓN DEL CARACTER QUE ESTAMOS CALCULANDO
	
	; SI EL NÚMERO ES NEGATIVO, ESCRIBIMOS UN MENOS Y LO PROCESAMOS COMO SI FUERA POSITIVO
	ADD BX, 0
	JNS PROCESARPOSITIVO
	
	MOV BYTE PTR ES:[BP][SI], '-'
	INC SI
	NEG BX
	
	
PROCESARPOSITIVO:
	; COPIAR BX A DX AX EXTENDIENDO EN SIGNO PARA PODER HACER DIVISIÓN LARGA
	MOV DX, BX
	MOV CL, 15
	SAR DX, CL
	MOV AX, BX
	MOV BL, 0
	
	; DIVIDIMOS ENTRE 10000 PARA OBTENER LAS DECENAS DE MILLAR
	MOV DI, 10000
	IDIV DI
	SUB AX, 0
	JZ SIG1
	MOV BL, 1 ; MARCAR QUE YA HEMOS ENCONTRADO UN CARACTER NO NULO
	ADD AX, '0'
	MOV ES:[BP][SI], AX
	INC SI ; INCREMENTAR EL CONTADOR DE POSICIONES DE MEMORIA ESCRITAS
	
SIG1:
	MOV AX, DX
	MOV CL, 15
	SAR DX, CL
	MOV DI, 1000
	IDIV DI
	SUB BL, 0 ; SI YA HEMOS ENCONTRADO UN CARACTER QUE NO ES CERO, NO SALTAMOS AUNQUE ESTE LO SEA
	JNZ NOSIG2
	
	SUB AX, 0 ; SI ESTE CARACTER ES 0 (Y NO HEMOS ENCONTRADO OTROS NO NULOS ANTES), NO LO ESCRIBIMOS
	JZ SIG2
NOSIG2:
	MOV BL, 1 ; SI ESTE CARACTER NO ES NULO, YA NO SALTAREMOS SI LOS SIGUIENTES LO SON
	ADD AX, '0'
	MOV ES:[BP][SI], AX
	INC SI

SIG2:
	MOV AX, DX
	MOV CL, 15
	SAR DX, CL
	MOV DI, 100
	IDIV DI
	SUB BL, 0 ; SI YA HEMOS ENCONTRADO UN CARACTER QUE NO ES CERO, NO SALTAMOS AUNQUE ESTE LO SEA
	JNZ NOSIG3
	
	SUB AX, 0 ; SI ESTE CARACTER ES 0 (Y NO HEMOS ENCONTRADO OTROS NO NULOS ANTES), NO LO ESCRIBIMOS
	JZ SIG3
NOSIG3:
	MOV BL, 1 ; SI ESTE CARACTER NO ES NULO, YA NO SALTAREMOS SI LOS SIGUIENTES LO SON
	ADD AX, '0'
	MOV ES:[BP][SI], AX
	INC SI
	
SIG3:	
	MOV AX, DX
	MOV CL, 15
	SAR DX, CL
	MOV DI, 10
	IDIV DI
	SUB BL, 0 ; SI YA HEMOS ENCONTRADO UN CARACTER QUE NO ES CERO, NO SALTAMOS AUNQUE ESTE LO SEA
	JNZ NOSIG4
	
	SUB AX, 0 ; SI ESTE CARACTER ES 0 (Y NO HEMOS ENCONTRADO OTROS NO NULOS ANTES), NO LO ESCRIBIMOS
	JZ SIG4
NOSIG4:
	MOV BL, 1 ; SI ESTE CARACTER NO ES NULO, YA NO SALTAREMOS SI LOS SIGUIENTES LO SON
	ADD AX, '0'
	MOV ES:[BP][SI], AX
	INC SI
	
SIG4:
	ADD DX, '0'
	MOV ES:[BP][SI], DX
	
	; AÑADIR UN CARACTER PARA SEÑALIZAR EL FIN DE LA CADENA
	INC SI
	MOV BYTE PTR ES:[BP][SI], '$' 

	POP AX
	POP BP
	POP BX
	POP ES
	POP CX
	POP DI
	POP DX
	POP SI
	RET
PASARAASCII ENDP

; IMPRIME EN UNA LINEA LOS COEFICIENTES DE LA FILA QUE COMIENZA EN EL DI-ÉSIM0 ELEMENTO DE LA MATRIZ
IMPRIMIRFILAMATRIZ PROC NEAR
	PUSH DI
	PUSH SI
	PUSH AX
	PUSH BX
	PUSH CX
	PUSH DX
	
	MOV SI, 0
	MOV DL, '|'
	MOV AH, 2
	INT 21H
		
	SIG:
		; CARGAR EN BX UN ELEMENTO DE LA MATRIZ
		; ES NECESARIO HACER ESTO PORQUE PASARASCII ASUME QUE EL ENTERO ES DE 16 BITS
		MOV BH, MATRIX[DI]
		MOV CL, 8
		SAR BX, CL			; EXTENDER EN SIGNO
		
		; CONFIGURAR LA ZONA DE MEMORIA EN LA QUE GUARDAREMOS EL ASCII
		MOV DX, SEG NUMEROENASCII
		MOV AX, OFFSET NUMEROENASCII
		
		; PASAR BX A ASCII
		CALL PASARAASCII
		
		; GUARDAR EL OFFSET DE LA CADENA PARA IMPRIMIRLA
		MOV DX, OFFSET NUMEROENASCII
		
		; IMPRIMIR LA CADENA QUE REPRESENTA EL ELEMENTO
		CALL IMPRIMIR

		
		INC DI
		INC SI
		MOV CX, SI
		SUB CX, 3
		JZ SALIR
			
		MOV DL, ' '
		MOV AH, 2
		INT 21H
		JMP SIG
		
	SALIR:
		MOV DL, '|'
		MOV AH, 2
		INT 21H
		
		POP DX
		POP CX
		POP BX
		POP AX
		POP SI
		POP DI
		RET
IMPRIMIRFILAMATRIZ ENDP

; IMPRIMIR EL CONTENIDO DE LA CADENA EN LA DIRECCIÓN DE MEMORIA DS:DX
IMPRIMIR PROC NEAR
	PUSH AX
	
	; EL OFFSET DE LA CADENA YA ESTÁ EN DX POR LO QUE NO HACE FALTA MOV DX, OFFSET CADENA
	MOV AH, 9
	INT 21H
	
	POP AX
	RET
IMPRIMIR ENDP

; FIN DEL SEGMENTO DE CODIGO
CODE ENDS
; FIN DEL PROGRAMA INDICANDO DONDE COMIENZA LA EJECUCION
END INICIO 