;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; SBM PRÁCTICA 4.
;;;
;;; SERGIO CORDERO ROJAS Y ELIAS HERNANDIS PRIETO
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

LONG_BUFFER EQU 155
CR EQU 13 ; RETORNO DE CARRO

DATOS SEGMENT

; NO FINALIZAMOS LA CADENA PORQUE QUEREMOS QUE VUELVA A IMPRIMIR LA SIGUIENTE
MSG_ERROR DB 0AH, 'COMANDO NO RECONOCIDO', 0AH
MSG_MENU DB 'COD/DECOD/QUIT > $'
CODPROMPT DB 'COD > $'
DECODPROMPT DB 'DECOD > $'
MSG_DECOD_AUX DB 'INTRODUCE LA CADENA A DECODIFICAR', 0AH, '$'
MSG_DECOD DB 'DECOD', CR
MSG_COD DB 'COD', CR
MSG_QUIT DB 'QUIT', CR
BUFFER_LECTURA DB LONG_BUFFER DUP(0)

DATOS ENDS
;**************************************************************************
; DEFINICION DEL SEGMENTO DE PILA
PILA SEGMENT STACK "STACK"
DB 40H DUP (0) ;ejemplo de inicialización, 64 bytes inicializados a 0
PILA ENDS
;**************************************************************************
; DEFINICION DEL SEGMENTO EXTRA
EXTRA SEGMENT
RESULT DW 0,0 ;ejemplo de inicialización. 2 PALABRAS (4 BYTES)
EXTRA ENDS
;**************************************************************************
; DEFINICION DEL SEGMENTO DE CODIGO
CODE SEGMENT
ASSUME CS: CODE, DS: DATOS, ES: EXTRA, SS: PILA
; COMIENZO DEL PROCEDIMIENTO PRINCIPAL
INICIO PROC
; INICIALIZA LOS REGISTROS DE SEGMENTO CON SU VALOR
MOV AX, DATOS
MOV DS, AX
MOV AX, PILA
MOV SS, AX
MOV SP, 64 ; CARGA EL PUNTERO DE PILA CON EL VALOR MAS ALTO
; FIN DE LAS INICIALIZACIONES
; COMIENZO DEL PROGRAMA

; IMPRIMIR MENSAGE CON INSTRUCCIONES DE USO
MOV AH, 09H
MOV DX, OFFSET MSG_MENU
INT 21H

CALL FILTER_MENU

MAIN_LOOP:
  CMP AX, 1
  JE LLAMAR_A_CODIFICAR

  CMP AX, 2
  JE LLAMAR_A_DECODIFICAR

  CMP AX, 3
  JE MAIN_EXIT

  ; MOSTRAR UN MENSAJE DE ERROR
  MOV AH, 09H
  MOV DX, OFFSET MSG_ERROR
  INT 21H
  CALL FILTER_MENU
  JMP MAIN_LOOP

LLAMAR_A_CODIFICAR:
  CALL CODIFICAR
  JMP MAIN_LOOP

LLAMAR_A_DECODIFICAR:
  CALL DECODIFICAR
  JMP MAIN_LOOP

MAIN_EXIT:
  ; FIN DEL PROGRAMA
  MOV AX, 4C00H
  INT 21H
INICIO ENDP

;;
;; PIDE ENTRADA POR TECLADO. SI EL USUARIO INTRODUCE COD, DEVUELVE 1. SI
;; INTRODUCE DECOD, DEVUELVE 2. SI INTRODUCE QUIT, DEVUELVE 3. SI NO ES NINGUNA
;; DE LAS ANTERIORES DEVUELVE 0. LOS RESULTADOS SE DEVUELVEN EN AX.
;;
FILTER_MENU PROC
  PUSH BX DX

  ; LEER EL COMANDO DEL USUARIO POR TECLADO
  MOV AH, 0AH
  MOV DX, OFFSET BUFFER_LECTURA
  MOV BUFFER_LECTURA[0], LONG_BUFFER
  INT 21H

  ; IMPRIMIR UN SALTO DE LINEA
  MOV AH, 02H
  MOV DL, 0AH
  INT 21H

  ; DETECTAR SI EL USUARIO HA ELEGIDO COD
  MOV AX, OFFSET MSG_COD
  MOV BX, OFFSET BUFFER_LECTURA[2]
  CALL STRCMP
  CMP DX, 0
  JZ COD

  ; DETECTAR SI HA ELEGIDO DECOD
  MOV AX, OFFSET MSG_DECOD
  CALL STRCMP
  CMP DX, 0
  JZ DECOD

  ; DETECTAR SI HA ELEGIDO QUIT
  MOV AX, OFFSET MSG_QUIT
  CALL STRCMP
  CMP DX, 0
  JZ QUIT

  ; EL USUARIO NO HA ELEGIDO NINGUNA OPCIÓN DEL MENU AL INICIO DEL PROGRAMA
  MOV AX, 0
  JMP FILTER_MENU_EXIT

  COD:
    MOV AX, 1
    JMP FILTER_MENU_EXIT

  DECOD:
    MOV AX, 2
    JMP FILTER_MENU_EXIT

  QUIT:
    MOV AX, 3

  FILTER_MENU_EXIT:
    POP DX BX
    RET
FILTER_MENU ENDP

;;
;; PIDE POR TECLADO UNA CADENA Y LA CODIFICA. SI EL USUARIO INTRODUCE
;; DECOD O QUIT, LA FUNCIÓN TERMINA CON CÓDIGO APROPIADO EN AX. (EL
;; MISMO QUE FILTER_MENU).
;;
CODIFICAR PROC
  PUSH BX CX DX SI

INICIO_CODIFICAR:
  MOV CX, 0

  ; IMPRIMIR PROMPT
  MOV AH, 09H
  MOV DX, OFFSET CODPROMPT
  INT 21H

  ; LEER DE TECLADO
  CALL FILTER_MENU

  ; SI NO QUIERE CODIFICAR MÁS, SALIMOS
  CMP AX, 0
  JNZ CODIFICAR_EXIT

  ; SI NO, CODIFICAMOS
  MOV DX, OFFSET BUFFER_LECTURA[2]

  ; AÑADIR UN CARACTER DE FIN DE CADENA PARA SER COMPATIBLES CON P4A
  MOV CL, BUFFER_LECTURA[1]
  MOV SI, CX
  MOV BUFFER_LECTURA[SI + 2], '$'

  MOV AH, 10H ; CODIFICAR
  MOV BX, 0 ; IMPRIMIR PASO A PASO
  INT 57H ; LLAMAR A LA INTERRUPCIÓN
  JMP INICIO_CODIFICAR

  CODIFICAR_EXIT:
    POP SI DX CX BX
    RET
CODIFICAR ENDP


;;
;; PIDE POR TECLADO UNA CADENA Y LA DECODIFICA. SI EL USUARIO INTRODUCE
;; COD O QUIT, LA FUNCIÓN TERMINA CON CÓDIGO APROPIADO EN AX. (EL MISMO QUE FILTER_MENU).
;;
DECODIFICAR PROC
  PUSH BX CX DX SI

INICIO_DECODIFICAR:
  MOV CX, 0

  ; IMPRIMIR PROMPT
  MOV AH, 09H
  MOV DX, OFFSET DECODPROMPT
  INT 21H

  ; LEER DE TECLADO
  CALL FILTER_MENU

  ; SI NO QUIERE CODIFICAR MÁS, SALIMOS
  CMP AX, 0
  JNZ DECODIFICAR_EXIT

  ; SI NO, DECODIFICAMOS
  MOV DX, OFFSET BUFFER_LECTURA[2]

  ; AÑADIR UN CARACTER DE FIN DE CADENA PARA SER COMPATIBLES CON P4A
  MOV CL, BUFFER_LECTURA[1]
  MOV SI, CX
  MOV BUFFER_LECTURA[SI + 2], '$'

  MOV AH, 11 ; DECODIFICAR
  MOV BX, 0 ; IMPRIMIR PASO A PASO
  INT 57H ; LLAMAR A LA INTERRUPCIÓN
  JMP INICIO_DECODIFICAR

  DECODIFICAR_EXIT:
    POP SI DX CX BX
    RET
DECODIFICAR ENDP

;;
;; COMPARA LAS CADENAS EN DS:AX Y DS:BX
;; DEVUELVE EN DX: 0 SI SON IGUALES Y OTRO NÚMERO SI SON DISTINTAS
;;
STRCMP PROC
  PUSH SI BP

  MOV BP, AX
  MOV SI, 0
  MOV DX, 0
  CADACARACTER:
    ADD DL, DS:BP[SI]
    SUB DL, DS:BX[SI]

    CMP BYTE PTR DS:BP[SI], CR
    JZ EXIT_STRCMP

    CMP BYTE PTR DS:BX[SI], CR
    JZ EXIT_STRCMP

    INC SI
    JMP CADACARACTER

  EXIT_STRCMP:
    POP BP SI
    RET
STRCMP ENDP

; FIN DEL SEGMENTO DE CODIGO
CODE ENDS
; FIN DEL PROGRAMA INDICANDO DONDE COMIENZA LA EJECUCION
END INICIO
